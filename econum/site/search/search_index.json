{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue sur la documentation Econum Ce site pr\u00e9sente l'architecture, l\u2019impl\u00e9mentation, les performances et les optimisations du projet Econum . Description du projet Econum est une solution logicielle permettant de simuler l\u2019\u00e9volution de la temp\u00e9rature d'un c\u00e2ble \u00e9lectrique pendant 30 minutes, en fonction de param\u00e8tres environnementaux (temp\u00e9rature ambiante, vent, intensit\u00e9 lumineuse). Architecture Le projet est divis\u00e9 en deux parties principales : - Backend : D\u00e9velopp\u00e9 en Python avec FastAPI, il g\u00e8re la simulation de temp\u00e9rature et les m\u00e9triques de performance. - Frontend : D\u00e9velopp\u00e9 en React et Next.js, il fournit une interface utilisateur pour interagir avec le backend et visualiser les r\u00e9sultats de la simulation. Code source \ud83d\udce6 Code source sur GitHub","title":"Accueil"},{"location":"#bienvenue-sur-la-documentation-econum","text":"Ce site pr\u00e9sente l'architecture, l\u2019impl\u00e9mentation, les performances et les optimisations du projet Econum .","title":"Bienvenue sur la documentation Econum"},{"location":"#description-du-projet","text":"Econum est une solution logicielle permettant de simuler l\u2019\u00e9volution de la temp\u00e9rature d'un c\u00e2ble \u00e9lectrique pendant 30 minutes, en fonction de param\u00e8tres environnementaux (temp\u00e9rature ambiante, vent, intensit\u00e9 lumineuse).","title":"Description du projet"},{"location":"#architecture","text":"Le projet est divis\u00e9 en deux parties principales : - Backend : D\u00e9velopp\u00e9 en Python avec FastAPI, il g\u00e8re la simulation de temp\u00e9rature et les m\u00e9triques de performance. - Frontend : D\u00e9velopp\u00e9 en React et Next.js, il fournit une interface utilisateur pour interagir avec le backend et visualiser les r\u00e9sultats de la simulation.","title":"Architecture"},{"location":"#code-source","text":"\ud83d\udce6 Code source sur GitHub","title":"Code source"},{"location":"backend/","text":"Backend - Fiche de configuration Description Le backend est d\u00e9velopp\u00e9 en Python avec le framework FastAPI. Il permet: - La simulation de temp\u00e9rature sur 30 minutes, \u00e0 partir de param\u00e8tres fournis par l\u2019utilisateur (temp\u00e9rature initiale, vent, intensit\u00e9\u2026). - La mesure de l\u2019\u00e9nergie et les ressources consomm\u00e9e ainsi que les \u00e9missions de CO\u2082 lors du calcul. - Une API REST pour requ\u00eates GET de simulation ou m\u00e9triques. Technologies utilis\u00e9es FastAPI : API REST performante CodeCarbon : suivi de l\u2019empreinte carbone et de la consommation de ressources @lru_cache : mise en cache pour \u00e9viter les recalculs Numba : compilation JIT pour acc\u00e9l\u00e9rer les calculs lourds Cython (optionnel) : alternative pour Numba Pr\u00e9requis Python 3.13+ Cython install\u00e9 avec pip Visual Studio avec le composant \"D\u00e9veloppement Desktop en C++\" Configuration Acc\u00e9der au dossier Back-end : cd Back-end Installer les d\u00e9pendances : pip install -r requirement.txt Ex\u00e9cuter l'application : uvicorn main:app --reload Acc\u00e9der \u00e0 l'application : http://127.0.0.1:8000/ Documentation API Swagger : http://127.0.0.1:8000/docs Et ReDoc : http://127.0.0.1:8000/redoc Tests d'API /!\\ Par d\u00e9faut le cache est activ\u00e9, ce qui permet d'\u00e9viter les recalculs inutiles. Url d'exemple pour tester l'API : http://127.0.0.1:8000/predict?Tc0=25&Ta=20&ws=2&I=100 http://127.0.0.1:8000/metrics_detailed?Tc0=25&Ta=20&ws=2&I=100 Cython /!\\ Installer Cython avec pip et \"D\u00e9veloppement Desktop en C++\" sur Visual Studio avant ! Acc\u00e9der au dossier Cython : cd cython Installer Cython : pip install cython Compiler le code : python setup.py build_ext --inplace Ex\u00e9cuter le code : python main.py","title":"Backend"},{"location":"backend/#backend-fiche-de-configuration","text":"","title":"Backend - Fiche de configuration"},{"location":"backend/#description","text":"Le backend est d\u00e9velopp\u00e9 en Python avec le framework FastAPI. Il permet: - La simulation de temp\u00e9rature sur 30 minutes, \u00e0 partir de param\u00e8tres fournis par l\u2019utilisateur (temp\u00e9rature initiale, vent, intensit\u00e9\u2026). - La mesure de l\u2019\u00e9nergie et les ressources consomm\u00e9e ainsi que les \u00e9missions de CO\u2082 lors du calcul. - Une API REST pour requ\u00eates GET de simulation ou m\u00e9triques.","title":"Description"},{"location":"backend/#technologies-utilisees","text":"FastAPI : API REST performante CodeCarbon : suivi de l\u2019empreinte carbone et de la consommation de ressources @lru_cache : mise en cache pour \u00e9viter les recalculs Numba : compilation JIT pour acc\u00e9l\u00e9rer les calculs lourds Cython (optionnel) : alternative pour Numba","title":"Technologies utilis\u00e9es"},{"location":"backend/#prerequis","text":"Python 3.13+ Cython install\u00e9 avec pip Visual Studio avec le composant \"D\u00e9veloppement Desktop en C++\"","title":"Pr\u00e9requis"},{"location":"backend/#configuration","text":"Acc\u00e9der au dossier Back-end : cd Back-end Installer les d\u00e9pendances : pip install -r requirement.txt Ex\u00e9cuter l'application : uvicorn main:app --reload Acc\u00e9der \u00e0 l'application : http://127.0.0.1:8000/","title":"Configuration"},{"location":"backend/#documentation-api","text":"Swagger : http://127.0.0.1:8000/docs Et ReDoc : http://127.0.0.1:8000/redoc","title":"Documentation API"},{"location":"backend/#tests-dapi","text":"/!\\ Par d\u00e9faut le cache est activ\u00e9, ce qui permet d'\u00e9viter les recalculs inutiles. Url d'exemple pour tester l'API : http://127.0.0.1:8000/predict?Tc0=25&Ta=20&ws=2&I=100 http://127.0.0.1:8000/metrics_detailed?Tc0=25&Ta=20&ws=2&I=100","title":"Tests d'API"},{"location":"backend/#cython","text":"/!\\ Installer Cython avec pip et \"D\u00e9veloppement Desktop en C++\" sur Visual Studio avant ! Acc\u00e9der au dossier Cython : cd cython Installer Cython : pip install cython Compiler le code : python setup.py build_ext --inplace Ex\u00e9cuter le code : python main.py","title":"Cython"},{"location":"frontend/","text":"Frontend \u2013 Fiche de configuration Description Le frontend est une application React et Next.js qui : - Affiche graphiquement l\u2019\u00e9volution de la temp\u00e9rature simul\u00e9e - Pr\u00e9sente les r\u00e9sultats dans les graphiques de visualisation d\u00e9di\u00e9s - Communique dynamiquement avec le backend via API Pr\u00e9requis Node.js + npm Le backend doit \u00eatre lanc\u00e9 Configuration Acc\u00e9der au dossier Frontend : cd Frontend Installer les d\u00e9pendances : npm install Ex\u00e9cuter l'application : npm run dev Acc\u00e9der local \u00e0 l'application : http://localhost:3000/ Structure du projet src/ : Contient le code source de l'application, y compris les composants, pages, et styles. public/ : Contient les fichiers statiques tels que les images et les fichiers de configuration. Notes Consultez la documentation du backend pour plus de d\u00e9tails sur les points de terminaison disponibles.","title":"Frontend"},{"location":"frontend/#frontend-fiche-de-configuration","text":"","title":"Frontend \u2013 Fiche de configuration"},{"location":"frontend/#description","text":"Le frontend est une application React et Next.js qui : - Affiche graphiquement l\u2019\u00e9volution de la temp\u00e9rature simul\u00e9e - Pr\u00e9sente les r\u00e9sultats dans les graphiques de visualisation d\u00e9di\u00e9s - Communique dynamiquement avec le backend via API","title":"Description"},{"location":"frontend/#prerequis","text":"Node.js + npm Le backend doit \u00eatre lanc\u00e9","title":"Pr\u00e9requis"},{"location":"frontend/#configuration","text":"Acc\u00e9der au dossier Frontend : cd Frontend Installer les d\u00e9pendances : npm install Ex\u00e9cuter l'application : npm run dev Acc\u00e9der local \u00e0 l'application : http://localhost:3000/","title":"Configuration"},{"location":"frontend/#structure-du-projet","text":"src/ : Contient le code source de l'application, y compris les composants, pages, et styles. public/ : Contient les fichiers statiques tels que les images et les fichiers de configuration.","title":"Structure du projet"},{"location":"frontend/#notes","text":"Consultez la documentation du backend pour plus de d\u00e9tails sur les points de terminaison disponibles.","title":"Notes"},{"location":"notebook/","text":"Notebook de tests Le fichier suivant contient les tests : \ud83d\udcc4 notebook.ipynb","title":"Notebook de test"},{"location":"notebook/#notebook-de-tests","text":"Le fichier suivant contient les tests : \ud83d\udcc4 notebook.ipynb","title":"Notebook de tests"},{"location":"rapport/","text":"Rapport de projet Architecture du projet Backend API dans Back-end/ main.py : Serveur FastAPI Solver.py : Calcul des temp\u00e9ratures notebook.ipynb : Tests cython/ : Optimisation avec cython requirement.txt : D\u00e9pendances Frontend Application React et Next.js dans Frontend/ Connexion au backend via appels API Le backend et le frontend sont s\u00e9par\u00e9s dans des sous-dossiers du m\u00eame d\u00e9p\u00f4t. Performances algorithmiques Testcase CPU RAM \u00c9nergie CO2 Temps d\u2019ex\u00e9cution Temps de code Complexit\u00e9* Python ~0.0217 kWh ~0.0006 kWh ~0.02336 kWh ~0.0013 kg ~217.1s 45 min *** Scipy odeint ~7.33e-07 kWh ~6.66e-09 kWh ~7.39e-07 kWh ~4.14e-08 kg ~0.009s 30 min ** Numba ~0.0014 kWh ~4.03e-05 kWh ~0.0016 kWh ~8.83e-05 kg ~14.5s 5 min * Cython ~0.0031 kWh ~8.55e-05 kWh ~0.0032 kWh ~0.0002 kg ~15.4s 1h **** * Complexit\u00e9 estim\u00e9e : (* = simple, ***** = tr\u00e8s complexe) Pr\u00e9vision 30x1min vs 1x30min M\u00e9thode \u00c9nergie CO2 Temps 1x30min ~0.0217 kWh ~0.0013 kg ~217.1s 30x1min ~0.014 kWh ~0.0008 kg ~140.3s Il est donc pr\u00e9f\u00e9rable de faire 30x1 minutes. Le code Python est mieux optimis\u00e9, principalement parce qu'il ne v\u00e9rifie pas si nous devons sauvegard\u00e9e l'information (v\u00e9rification faite autant de fois qu'il y a de calculs, soit 1,8 milliard). Mais le passage avec Numba ou Cython, cela n'a aucun impact. Backend : consommation par utilisateurs Charge Conso (kWh) 10 utilisateurs/min (sans cache) 0.018966 100 utilisateurs/min (sans cache) 0.156688 1000 utilisateurs/min (sans cache) 17.317401 1000 utilisateurs/min (cache) 0.002516 Nous observons une tendance logique : Plus le nombre d'utilisateurs augmente, plus la consommation moyenne augmente. \u00c0 l'inverse, avec l'ajout du cache, la consommation reste minimale si les param\u00e8tres d'entr\u00e9e ont d\u00e9j\u00e0 \u00e9t\u00e9 calcul\u00e9s. Nous constatons ainsi l'avantage du cache : une consommation plus faible et une r\u00e9activit\u00e9 nettement sup\u00e9rieure. Empreinte \u00e9nerg\u00e9tique du frontend L'empreinte \u00e9nerg\u00e9tique et carbone a \u00e9t\u00e9 analys\u00e9e avec Carbonalyser et Globemallow, sur les deux outils nous avons des r\u00e9sultats diff\u00e9rents mais qui semblent assez proches de la r\u00e9alit\u00e9 : Carbonalyser Globemallow Impact du cache N\u00e9anmoins, nous pouvons voir que le cache permet totalement d\u2019optimiser la consommation en la rendant presque ind\u00e9tectable :","title":"Rapport"},{"location":"rapport/#rapport-de-projet","text":"","title":"Rapport de projet"},{"location":"rapport/#architecture-du-projet","text":"","title":"Architecture du projet"},{"location":"rapport/#backend","text":"API dans Back-end/ main.py : Serveur FastAPI Solver.py : Calcul des temp\u00e9ratures notebook.ipynb : Tests cython/ : Optimisation avec cython requirement.txt : D\u00e9pendances","title":"Backend"},{"location":"rapport/#frontend","text":"Application React et Next.js dans Frontend/ Connexion au backend via appels API Le backend et le frontend sont s\u00e9par\u00e9s dans des sous-dossiers du m\u00eame d\u00e9p\u00f4t.","title":"Frontend"},{"location":"rapport/#performances-algorithmiques","text":"Testcase CPU RAM \u00c9nergie CO2 Temps d\u2019ex\u00e9cution Temps de code Complexit\u00e9* Python ~0.0217 kWh ~0.0006 kWh ~0.02336 kWh ~0.0013 kg ~217.1s 45 min *** Scipy odeint ~7.33e-07 kWh ~6.66e-09 kWh ~7.39e-07 kWh ~4.14e-08 kg ~0.009s 30 min ** Numba ~0.0014 kWh ~4.03e-05 kWh ~0.0016 kWh ~8.83e-05 kg ~14.5s 5 min * Cython ~0.0031 kWh ~8.55e-05 kWh ~0.0032 kWh ~0.0002 kg ~15.4s 1h **** * Complexit\u00e9 estim\u00e9e : (* = simple, ***** = tr\u00e8s complexe)","title":"Performances algorithmiques"},{"location":"rapport/#prevision-30x1min-vs-1x30min","text":"M\u00e9thode \u00c9nergie CO2 Temps 1x30min ~0.0217 kWh ~0.0013 kg ~217.1s 30x1min ~0.014 kWh ~0.0008 kg ~140.3s Il est donc pr\u00e9f\u00e9rable de faire 30x1 minutes. Le code Python est mieux optimis\u00e9, principalement parce qu'il ne v\u00e9rifie pas si nous devons sauvegard\u00e9e l'information (v\u00e9rification faite autant de fois qu'il y a de calculs, soit 1,8 milliard). Mais le passage avec Numba ou Cython, cela n'a aucun impact.","title":"Pr\u00e9vision 30x1min vs 1x30min"},{"location":"rapport/#backend-consommation-par-utilisateurs","text":"Charge Conso (kWh) 10 utilisateurs/min (sans cache) 0.018966 100 utilisateurs/min (sans cache) 0.156688 1000 utilisateurs/min (sans cache) 17.317401 1000 utilisateurs/min (cache) 0.002516 Nous observons une tendance logique : Plus le nombre d'utilisateurs augmente, plus la consommation moyenne augmente. \u00c0 l'inverse, avec l'ajout du cache, la consommation reste minimale si les param\u00e8tres d'entr\u00e9e ont d\u00e9j\u00e0 \u00e9t\u00e9 calcul\u00e9s. Nous constatons ainsi l'avantage du cache : une consommation plus faible et une r\u00e9activit\u00e9 nettement sup\u00e9rieure.","title":"Backend : consommation par utilisateurs"},{"location":"rapport/#empreinte-energetique-du-frontend","text":"L'empreinte \u00e9nerg\u00e9tique et carbone a \u00e9t\u00e9 analys\u00e9e avec Carbonalyser et Globemallow, sur les deux outils nous avons des r\u00e9sultats diff\u00e9rents mais qui semblent assez proches de la r\u00e9alit\u00e9 :","title":"Empreinte \u00e9nerg\u00e9tique du frontend"},{"location":"rapport/#carbonalyser","text":"","title":"Carbonalyser"},{"location":"rapport/#globemallow","text":"","title":"Globemallow"},{"location":"rapport/#impact-du-cache","text":"N\u00e9anmoins, nous pouvons voir que le cache permet totalement d\u2019optimiser la consommation en la rendant presque ind\u00e9tectable :","title":"Impact du cache"},{"location":"recommandations/","text":"Recommandations d'optimisation Backend R\u00e9duire la consommation RAM : stocker uniquement les donn\u00e9es finales. R\u00e9duire le recalcul inutile (vent, intensit\u00e9...). Utiliser des outils comme Numba ou Cython pour am\u00e9liorer les performances. Utiliser @lru_cache pour \u00e9viter les redondances de calcul. Pr\u00e9f\u00e9rer d'une m\u00e9thode de calcul 30x1min plut\u00f4t que 1x30min pour optimiser la logique de calcul et \u00e9viter les conditions r\u00e9p\u00e9t\u00e9es. Frontend Utiliser un framework l\u00e9ger. R\u00e9duire les appels r\u00e9seau inutiles. Minimiser les assets (images, JS...).","title":"Recommandations"},{"location":"recommandations/#recommandations-doptimisation","text":"","title":"Recommandations d'optimisation"},{"location":"recommandations/#backend","text":"R\u00e9duire la consommation RAM : stocker uniquement les donn\u00e9es finales. R\u00e9duire le recalcul inutile (vent, intensit\u00e9...). Utiliser des outils comme Numba ou Cython pour am\u00e9liorer les performances. Utiliser @lru_cache pour \u00e9viter les redondances de calcul. Pr\u00e9f\u00e9rer d'une m\u00e9thode de calcul 30x1min plut\u00f4t que 1x30min pour optimiser la logique de calcul et \u00e9viter les conditions r\u00e9p\u00e9t\u00e9es.","title":"Backend"},{"location":"recommandations/#frontend","text":"Utiliser un framework l\u00e9ger. R\u00e9duire les appels r\u00e9seau inutiles. Minimiser les assets (images, JS...).","title":"Frontend"}]}